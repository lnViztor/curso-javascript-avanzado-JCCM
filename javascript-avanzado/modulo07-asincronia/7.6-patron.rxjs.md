## 7.5 Patrón RxJS

⚡ **¿Qué es RxJS?**
**RxJS (Reactive Extensions for JavaScript)** es una **librería para programación reactiva** basada en el **patrón Observer**.
Permite trabajar con **flujos de datos asíncronos** (eventos, HTTP, websockets, timers...) de forma **declarativa** y **componible**.

---

### 💡 Filosofía del patrón RxJS

> *Todo es un stream, y todo se puede observar.*

* Un **Observable** representa un *flujo de datos* que puede emitir muchos valores en el tiempo.
* Un **Observer** reacciona a esos valores mediante `next`, `error` y `complete`.
* Los **operadores** permiten *transformar, combinar y filtrar* los flujos sin escribir callbacks anidados.

---

### ✅ El patrón en acción

El flujo típico en RxJS sigue el patrón:
**Creación → Transformación → Suscripción → Cancelación**

```js
import { fromEvent, map, filter } from "rxjs";

// 1️⃣ Creación: observable desde eventos DOM
const clicks$ = fromEvent(document, "click");

// 2️⃣ Transformación: extraer coordenadas y filtrar
const coords$ = clicks$.pipe(
  map(ev => ({ x: ev.clientX, y: ev.clientY })),
  filter(pos => pos.x > 100)
);

// 3️⃣ Suscripción: reaccionar a cada valor
const subscription = coords$.subscribe(pos =>
  console.log("Click válido en:", pos)
);

// 4️⃣ Cancelación
setTimeout(() => subscription.unsubscribe(), 5000);
```

---

### 🧱 Patrón Observer clásico (concepto base)

```js
const observable = {
  observers: [],
  subscribe(fn) {
    this.observers.push(fn);
  },
  emit(valor) {
    this.observers.forEach(fn => fn(valor));
  }
};

observable.subscribe(data => console.log("👂", data));
observable.emit("Hola RxJS!");
```

📤 **Salida:**

```
👂 Hola RxJS!
```

> RxJS amplía este patrón con cancelaciones, errores, composición funcional y manejo de tiempo.

---

### 🔧 Operadores más usados

| Tipo              | Operadores comunes                        | Ejemplo             |
| ----------------- | ----------------------------------------- | ------------------- |
| Creación          | `of`, `from`, `interval`, `fromEvent`     | `from([1,2,3])`     |
| Transformación    | `map`, `filter`, `scan`                   | `map(x => x*2)`     |
| Combinación       | `merge`, `concat`, `combineLatest`, `zip` | `merge(obs1, obs2)` |
| Control de tiempo | `debounceTime`, `delay`, `throttleTime`   | `debounceTime(300)` |
| Error             | `catchError`, `retry`                     | `retry(2)`          |

---

### 🔄 Flujo visual del patrón RxJS

```
[Fuente de datos] → [Observable]
          ↓
  [Operadores (pipe)]
          ↓
     [Suscriptor]
```

📘 Ejemplo conceptual:

```js
fetch('https://api.ejemplo.com/users')
→ Observable de respuesta HTTP
→ map() para transformar JSON
→ filter() para usuarios activos
→ subscribe() para renderizar en pantalla
```

---

### 🧯 Manejo de errores reactivo

```js
import { of, throwError, catchError } from "rxjs";

throwError(() => new Error("Fallo de red"))
  .pipe(catchError(err => of("⚠️ Error controlado: " + err.message)))
  .subscribe(console.log);
```

---

### 🚦 Flujo completo con RxJS

```js
import { of, map, filter, tap } from "rxjs";

of(10, 20, 30, 40)
  .pipe(
    tap(v => console.log("🟡 Antes:", v)),
    filter(v => v >= 20),
    map(v => v / 10),
    tap(v => console.log("🟢 Después:", v))
  )
  .subscribe({
    next: v => console.log("✅ Valor final:", v),
    complete: () => console.log("🏁 Completado")
  });
```

📤 **Salida:**

```
🟡 Antes: 10
🟡 Antes: 20
🟢 Después: 2
✅ Valor final: 2
🟡 Antes: 30
🟢 Después: 3
✅ Valor final: 3
🟡 Antes: 40
🟢 Después: 4
✅ Valor final: 4
🏁 Completado
```

---

## 🛠 Laboratorio

### 🎯 Objetivos

* Comprender el patrón Observer y su implementación en RxJS
* Crear y transformar streams de datos
* Manejar errores de forma reactiva
* Cancelar suscripciones correctamente

---

### 🧪 Ejercicio 1 — Implementar el patrón Observer simple

```js
const subject = {
  observers: [],
  subscribe(fn) { this.observers.push(fn); },
  next(valor) { this.observers.forEach(fn => fn(valor)); }
};

subject.subscribe(v => console.log("Receptor A:", v));
subject.subscribe(v => console.log("Receptor B:", v));

subject.next("Evento 1");
subject.next("Evento 2");
```

---

### 🧪 Ejercicio 2 — Patrón RxJS con `fromEvent`

```js
import { fromEvent } from "rxjs";

const input = document.querySelector("input");
fromEvent(input, "input").subscribe(ev =>
  console.log("📥 Valor:", ev.target.value)
);
```

---

### 🧪 Ejercicio 3 — Patrón reactivo con transformación

```js
import { fromEvent, map, filter } from "rxjs";

fromEvent(document, "keydown")
  .pipe(
    map(e => e.key),
    filter(k => k === "Enter")
  )
  .subscribe(() => console.log("⏎ Enter detectado"));
```

---

### 🧪 Ejercicio 4 — Cancelar flujo reactivo

```js
import { interval, takeUntil, timer } from "rxjs";

const flujo$ = interval(500);
const stop$ = timer(3000);

flujo$.pipe(takeUntil(stop$)).subscribe({
  next: v => console.log("Tick", v),
  complete: () => console.log("🛑 Detenido por patrón RxJS")
});
```

---

### 🧪 Ejercicio 5 — Patrón con múltiples fuentes

```js
import { fromEvent, merge } from "rxjs";

const clicks$ = fromEvent(document, "click");
const teclas$ = fromEvent(document, "keydown");

merge(clicks$, teclas$).subscribe(() =>
  console.log("🧩 Acción del usuario detectada")
);
```

---

## 🚀 Retos

1. Crea un `Subject` que emita cada vez que un botón sea clicado y logre propagar el evento a múltiples suscriptores.
2. Usa `debounceTime` y `map` para crear un buscador reactivo con `input`.
3. Combina dos flujos (`mousemove` y `keydown`) con `combineLatest`.
4. Simula un sistema de “notificaciones push” con `interval` y `map`.
5. Implementa un contador que se reinicia cuando se hace clic en pantalla.