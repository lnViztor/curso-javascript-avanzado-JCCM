## 7.5 PatrÃ³n RxJS

âš¡ **Â¿QuÃ© es RxJS?**
**RxJS (Reactive Extensions for JavaScript)** es una **librerÃ­a para programaciÃ³n reactiva** basada en el **patrÃ³n Observer**.
Permite trabajar con **flujos de datos asÃ­ncronos** (eventos, HTTP, websockets, timers...) de forma **declarativa** y **componible**.

---

### ğŸ’¡ FilosofÃ­a del patrÃ³n RxJS

> *Todo es un stream, y todo se puede observar.*

* Un **Observable** representa un *flujo de datos* que puede emitir muchos valores en el tiempo.
* Un **Observer** reacciona a esos valores mediante `next`, `error` y `complete`.
* Los **operadores** permiten *transformar, combinar y filtrar* los flujos sin escribir callbacks anidados.

---

### âœ… El patrÃ³n en acciÃ³n

El flujo tÃ­pico en RxJS sigue el patrÃ³n:
**CreaciÃ³n â†’ TransformaciÃ³n â†’ SuscripciÃ³n â†’ CancelaciÃ³n**

```js
import { fromEvent, map, filter } from "rxjs";

// 1ï¸âƒ£ CreaciÃ³n: observable desde eventos DOM
const clicks$ = fromEvent(document, "click");

// 2ï¸âƒ£ TransformaciÃ³n: extraer coordenadas y filtrar
const coords$ = clicks$.pipe(
  map(ev => ({ x: ev.clientX, y: ev.clientY })),
  filter(pos => pos.x > 100)
);

// 3ï¸âƒ£ SuscripciÃ³n: reaccionar a cada valor
const subscription = coords$.subscribe(pos =>
  console.log("Click vÃ¡lido en:", pos)
);

// 4ï¸âƒ£ CancelaciÃ³n
setTimeout(() => subscription.unsubscribe(), 5000);
```

---

### ğŸ§± PatrÃ³n Observer clÃ¡sico (concepto base)

```js
const observable = {
  observers: [],
  subscribe(fn) {
    this.observers.push(fn);
  },
  emit(valor) {
    this.observers.forEach(fn => fn(valor));
  }
};

observable.subscribe(data => console.log("ğŸ‘‚", data));
observable.emit("Hola RxJS!");
```

ğŸ“¤ **Salida:**

```
ğŸ‘‚ Hola RxJS!
```

> RxJS amplÃ­a este patrÃ³n con cancelaciones, errores, composiciÃ³n funcional y manejo de tiempo.

---

### ğŸ”§ Operadores mÃ¡s usados

| Tipo              | Operadores comunes                        | Ejemplo             |
| ----------------- | ----------------------------------------- | ------------------- |
| CreaciÃ³n          | `of`, `from`, `interval`, `fromEvent`     | `from([1,2,3])`     |
| TransformaciÃ³n    | `map`, `filter`, `scan`                   | `map(x => x*2)`     |
| CombinaciÃ³n       | `merge`, `concat`, `combineLatest`, `zip` | `merge(obs1, obs2)` |
| Control de tiempo | `debounceTime`, `delay`, `throttleTime`   | `debounceTime(300)` |
| Error             | `catchError`, `retry`                     | `retry(2)`          |

---

### ğŸ”„ Flujo visual del patrÃ³n RxJS

```
[Fuente de datos] â†’ [Observable]
          â†“
  [Operadores (pipe)]
          â†“
     [Suscriptor]
```

ğŸ“˜ Ejemplo conceptual:

```js
fetch('https://api.ejemplo.com/users')
â†’ Observable de respuesta HTTP
â†’ map() para transformar JSON
â†’ filter() para usuarios activos
â†’ subscribe() para renderizar en pantalla
```

---

### ğŸ§¯ Manejo de errores reactivo

```js
import { of, throwError, catchError } from "rxjs";

throwError(() => new Error("Fallo de red"))
  .pipe(catchError(err => of("âš ï¸ Error controlado: " + err.message)))
  .subscribe(console.log);
```

---

### ğŸš¦ Flujo completo con RxJS

```js
import { of, map, filter, tap } from "rxjs";

of(10, 20, 30, 40)
  .pipe(
    tap(v => console.log("ğŸŸ¡ Antes:", v)),
    filter(v => v >= 20),
    map(v => v / 10),
    tap(v => console.log("ğŸŸ¢ DespuÃ©s:", v))
  )
  .subscribe({
    next: v => console.log("âœ… Valor final:", v),
    complete: () => console.log("ğŸ Completado")
  });
```

ğŸ“¤ **Salida:**

```
ğŸŸ¡ Antes: 10
ğŸŸ¡ Antes: 20
ğŸŸ¢ DespuÃ©s: 2
âœ… Valor final: 2
ğŸŸ¡ Antes: 30
ğŸŸ¢ DespuÃ©s: 3
âœ… Valor final: 3
ğŸŸ¡ Antes: 40
ğŸŸ¢ DespuÃ©s: 4
âœ… Valor final: 4
ğŸ Completado
```

---

## ğŸ›  Laboratorio

### ğŸ¯ Objetivos

* Comprender el patrÃ³n Observer y su implementaciÃ³n en RxJS
* Crear y transformar streams de datos
* Manejar errores de forma reactiva
* Cancelar suscripciones correctamente

---

### ğŸ§ª Ejercicio 1 â€” Implementar el patrÃ³n Observer simple

```js
const subject = {
  observers: [],
  subscribe(fn) { this.observers.push(fn); },
  next(valor) { this.observers.forEach(fn => fn(valor)); }
};

subject.subscribe(v => console.log("Receptor A:", v));
subject.subscribe(v => console.log("Receptor B:", v));

subject.next("Evento 1");
subject.next("Evento 2");
```

---

### ğŸ§ª Ejercicio 2 â€” PatrÃ³n RxJS con `fromEvent`

```js
import { fromEvent } from "rxjs";

const input = document.querySelector("input");
fromEvent(input, "input").subscribe(ev =>
  console.log("ğŸ“¥ Valor:", ev.target.value)
);
```

---

### ğŸ§ª Ejercicio 3 â€” PatrÃ³n reactivo con transformaciÃ³n

```js
import { fromEvent, map, filter } from "rxjs";

fromEvent(document, "keydown")
  .pipe(
    map(e => e.key),
    filter(k => k === "Enter")
  )
  .subscribe(() => console.log("â Enter detectado"));
```

---

### ğŸ§ª Ejercicio 4 â€” Cancelar flujo reactivo

```js
import { interval, takeUntil, timer } from "rxjs";

const flujo$ = interval(500);
const stop$ = timer(3000);

flujo$.pipe(takeUntil(stop$)).subscribe({
  next: v => console.log("Tick", v),
  complete: () => console.log("ğŸ›‘ Detenido por patrÃ³n RxJS")
});
```

---

### ğŸ§ª Ejercicio 5 â€” PatrÃ³n con mÃºltiples fuentes

```js
import { fromEvent, merge } from "rxjs";

const clicks$ = fromEvent(document, "click");
const teclas$ = fromEvent(document, "keydown");

merge(clicks$, teclas$).subscribe(() =>
  console.log("ğŸ§© AcciÃ³n del usuario detectada")
);
```

---

## ğŸš€ Retos

1. Crea un `Subject` que emita cada vez que un botÃ³n sea clicado y logre propagar el evento a mÃºltiples suscriptores.
2. Usa `debounceTime` y `map` para crear un buscador reactivo con `input`.
3. Combina dos flujos (`mousemove` y `keydown`) con `combineLatest`.
4. Simula un sistema de â€œnotificaciones pushâ€ con `interval` y `map`.
5. Implementa un contador que se reinicia cuando se hace clic en pantalla.