# 7.2 Promises (Promesas)

## ðŸ’¡ Â¿QuÃ© es una Promesa?

Una **promesa** representa una operaciÃ³n que **todavÃ­a no ha terminado**, pero que lo harÃ¡ en el futuro.
Sirve para **reemplazar los callbacks anidados** y hacer el cÃ³digo asincrÃ³nico mÃ¡s limpio y legible.

Piensa en una promesa como un â€œvaleâ€:

> â€œPrometo devolverte algoâ€¦ pero todavÃ­a no lo tengoâ€.

---

## ðŸ”§ Sintaxis bÃ¡sica

```js
const promesa = new Promise((resolve, reject) => {
  // operaciÃ³n asincrÃ³nica
  const exito = true;
  if (exito) resolve("Todo bien âœ…");
  else reject("Algo fallÃ³ âŒ");
});
```

Las promesas tienen **3 estados**:

1. *pending* (pendiente)
2. *fulfilled* (resuelta con Ã©xito)
3. *rejected* (rechazada por error)

---

## âœ… Consumir una promesa

Se usan los mÃ©todos `.then()` y `.catch()` para reaccionar al resultado.

```js
promesa
  .then(resultado => console.log("Ã‰xito:", resultado))
  .catch(error => console.log("Error:", error));
```

---

## ðŸ§  Ejemplo completo

```js
const obtenerUsuario = new Promise((resolve, reject) => {
  setTimeout(() => {
    const ok = Math.random() > 0.3;
    if (ok) resolve({ nombre: "Ada", edad: 36 });
    else reject("No se pudo obtener el usuario");
  }, 1000);
});

obtenerUsuario
  .then(usuario => console.log("Usuario:", usuario))
  .catch(error => console.log("Error:", error));
```

---

## ðŸ”— Encadenar promesas

Las promesas se pueden encadenar para ejecutar varias operaciones en orden, sin el â€œinfierno de callbacksâ€.

```js
function paso1() {
  return Promise.resolve("Paso 1 completado");
}

function paso2() {
  return Promise.resolve("Paso 2 completado");
}

paso1()
  .then(resultado => {
    console.log(resultado);
    return paso2();
  })
  .then(resultado => console.log(resultado))
  .catch(error => console.log("Error:", error));
```

---

## âš¡ Promise.all

Ejecuta varias promesas en paralelo y espera que **todas terminen**.

```js
const p1 = Promise.resolve("Tarea 1");
const p2 = Promise.resolve("Tarea 2");
const p3 = Promise.resolve("Tarea 3");

Promise.all([p1, p2, p3]).then(res => console.log(res));
// ["Tarea 1", "Tarea 2", "Tarea 3"]
```

---

# ðŸ›  Laboratorio

## ðŸŽ¯ Objetivos

* Crear y resolver promesas
* Manejar errores con catch
* Encadenar promesas correctamente
* Evitar el â€œcallback hellâ€

---

### Ejercicio 1 â€” Promesa simple

Crea una promesa que se resuelva despuÃ©s de 2 segundos.

```js
const miPromesa = new Promise((resolve) => {
  setTimeout(() => resolve("Promesa cumplida ðŸŽ‰"), 2000);
});

miPromesa.then(mensaje => console.log(mensaje));
```

---

### Ejercicio 2 â€” Promesa con error

Simula un fallo aleatorio.

```js
const promesaAleatoria = new Promise((resolve, reject) => {
  const exito = Math.random() > 0.5;
  exito ? resolve("Todo saliÃ³ bien ðŸ˜Ž") : reject("Ups, fallÃ³ ðŸ˜¢");
});

promesaAleatoria
  .then(r => console.log("OK:", r))
  .catch(e => console.log("Error:", e));
```

---

### Ejercicio 3 â€” Promesas encadenadas

```js
function pasoA() {
  return Promise.resolve("Paso A listo");
}
function pasoB() {
  return Promise.resolve("Paso B listo");
}
pasoA()
  .then(m => { console.log(m); return pasoB(); })
  .then(m => console.log(m))
  .catch(e => console.log("Error:", e));
```

---

### Ejercicio 4 â€” Promise.all

```js
const fetch1 = Promise.resolve("Datos 1");
const fetch2 = Promise.resolve("Datos 2");
const fetch3 = Promise.resolve("Datos 3");

Promise.all([fetch1, fetch2, fetch3])
  .then(res => console.log("Todo listo:", res));
```

---

### Ejercicio 5 â€” Manejo de error real

```js
function obtenerDatos(url) {
  return new Promise((resolve, reject) => {
    if (!url.startsWith("http")) reject("URL invÃ¡lida");
    else setTimeout(() => resolve("Datos cargados âœ…"), 1000);
  });
}

obtenerDatos("https://api.ejemplo.com")
  .then(console.log)
  .catch(console.error);
```

---

## ðŸš€ Retos

1. Crea una funciÃ³n `esperar(ms)` que devuelva una promesa que se resuelva tras ms milisegundos.
2. Simula una llamada a API con 3 pasos encadenados (`login â†’ obtener datos â†’ mostrar datos`).
3. Usa `Promise.all` para esperar varias operaciones a la vez y mostrar los resultados juntos.

