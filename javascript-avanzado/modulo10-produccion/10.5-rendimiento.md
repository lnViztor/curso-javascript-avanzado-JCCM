AquÃ­ tienes **10.5 â€“ Ajuste de rendimiento en JavaScript (Performance Tuning)**. Este tema enseÃ±a tÃ©cnicas reales para optimizar la velocidad y eficiencia del cÃ³digo. Muy Ãºtil en producciÃ³n âš¡

---

# 10.5 Ajuste de rendimiento (Performance Tuning)

## ğŸš€ Â¿Por quÃ© optimizar?

Cuanto mÃ¡s grande es una aplicaciÃ³n, mÃ¡s importante es que funcione rÃ¡pido.
El rendimiento afecta:
âœ… UX (experiencia de usuario)
âœ… ConversiÃ³n en webs
âœ… Consumo de baterÃ­a en mÃ³viles
âœ… Posicionamiento SEO

---

## âš™ï¸ Principios clave

* **No optimices antes de medir**
* Evita **cÃ¡lculos innecesarios**
* Reduce **accesos al DOM** (son costosos)
* Evita **bucles pesados**
* Usa **estructuras eficientes** (`Map`, `Set`, etc.)

---

## âœ… TÃ©cnicas esenciales

### 1. Minimizar trabajo dentro de bucles

```js
// âŒ Mal
for (let i = 0; i < arr.length; i++) console.log(arr[i]);

// âœ… Mejor
for (const item of arr) console.log(item);
```

---

### 2. Usar cachÃ© o memoizaciÃ³n

```js
const cache = {};
function cuadrado(n) {
  if (cache[n]) return cache[n];
  cache[n] = n * n;
  return cache[n];
}
```

---

### 3. Evitar accesos innecesarios al DOM

```js
// âŒ Evitar recalcular elemento cada vez
for (let i = 0; i < 1000; i++) {
  document.getElementById("contador").textContent = i;
}

// âœ… Mejor â†’ guardar referencia
const c = document.getElementById("contador");
for (let i = 0; i < 1000; i++) c.textContent = i;
```

---

### 4. Debounce y throttle

Para evitar que funciones se ejecuten muchas veces en poco tiempo.

**Debounce (esperar a que termine de escribir, por ejemplo):**

```js
function debounce(fn, delay) {
  let id;
  return (...args) => {
    clearTimeout(id);
    id = setTimeout(() => fn(...args), delay);
  };
}
```

**Throttle (limitar velocidad de ejecuciÃ³n):**

```js
function throttle(fn, limit) {
  let esperando = false;
  return (...args) => {
    if (!esperando) {
      fn(...args);
      esperando = true;
      setTimeout(() => (esperando = false), limit);
    }
  };
}
```

---

### 5. Usar estructuras rÃ¡pidas

```js
const set = new Set([1, 2, 2, 3]); // elimina duplicados
set.has(2);  // rÃ¡pido
```

---

# ğŸ›  Laboratorio

## ğŸ¯ Objetivos

* Detectar cÃ³digo lento
* Usar tÃ©cnicas bÃ¡sicas de optimizaciÃ³n
* Reducir operaciones innecesarias

---

### Ejercicio 1 â€” Guardar referencia

```js
const titulo = document.getElementById("titulo");
// reutilizar 'titulo' en vez de buscarlo cada vez
```

---

### Ejercicio 2 â€” Optimizar bucles

```js
const lista = [1, 2, 3, 4, 5];
for (const item of lista) {
  console.log(item);
}
```

---

### Ejercicio 3 â€” Eliminando duplicados

```js
const nums = [1, 2, 2, 3, 4, 4];
const unicos = [...new Set(nums)];
```

---

### Ejercicio 4 â€” Debounce en buscador

```js
const buscador = document.getElementById("buscar");
const buscar = debounce((txt) => console.log("Buscando:", txt), 500);

buscador.addEventListener("input", e => buscar(e.target.value));
```

---

### Ejercicio 5 â€” Throttle en scroll

```js
window.addEventListener("scroll", throttle(() => {
  console.log("Scroll detectado");
}, 1000));
```

---

## ğŸš€ Retos

1. Optimiza una funciÃ³n pesada usando memoizaciÃ³n.
2. Reduce los reflows del DOM agrupando cambios.
3. Usa `performance.now()` para medir el tiempo que tarda en ejecutarse una funciÃ³n.