# 10.4 Memory Leaks en JavaScript

## ğŸ§  Â¿QuÃ© es un Memory Leak?

Un **memory leak (fuga de memoria)** ocurre cuando un programa **reserva memoria pero nunca la libera**, ocupando cada vez mÃ¡s RAM sin necesitarla.
Aunque JavaScript tiene **garbage collector automÃ¡tico**, **sÃ­ puede haber fugas de memoria** si el cÃ³digo mantiene referencias innecesarias.

---

## âš ï¸ Â¿Por quÃ© es peligroso?

Porque provoca:
âŒ Lentitud en la app
âŒ Bloqueos
âŒ Navegadores congelados
âŒ Mala experiencia de usuario

---

## ğŸ”¥ Causas comunes de memory leaks

### 1. Variables globales innecesarias

```js
leak = []; // sin let/const â†’ se vuelve global
```

---

### 2. Referencias no limpiadas

```js
let lista = document.querySelectorAll("li");
// ...mÃ¡s tarde
lista = null; // liberar referencia cuando ya no se usa
```

---

### 3. Event listeners no eliminados

```js
function saludar() {
  console.log("Hola");
}
button.addEventListener("click", saludar);
// Si no eliminas esto puede acumularse:
button.removeEventListener("click", saludar);
```

---

### 4. Timers sin limpiar

```js
const id = setInterval(() => console.log("Hola"), 1000);
// ...
clearInterval(id); // siempre limpiar
```

---

### 5. Closures mal usados

```js
function crearLeak() {
  const datosPesados = new Array(1000000).fill("ğŸ˜µ");
  return () => console.log("usando closure");
}
const leakFunc = crearLeak(); // datosPesados nunca se libera
```

---

## âœ… Buenas prÃ¡cticas para evitar fugas

âœ” Usa `let` y `const` siempre
âœ” Limpia listeners con `removeEventListener`
âœ” Limpia timers con `clearTimeout` o `clearInterval`
âœ” Evita acumular datos en arrays sin lÃ­mite
âœ” Usa herramientas de monitorizaciÃ³n (Chrome DevTools â†’ Memory)

---

# ğŸ›  Laboratorio

## ğŸ¯ Objetivos

* Detectar fugas de memoria comunes
* Evitar referencias innecesarias
* Limpiar listeners y timers correctamente

---

### Ejercicio 1 â€” CÃ³digo con fuga

Encuentra el problema:

```js
setInterval(() => console.log("Hola"), 1000);
```

SoluciÃ³n:

```js
const id = setInterval(() => console.log("Hola"), 1000);
// ...
clearInterval(id);
```

---

### Ejercicio 2 â€” Listener sin limpiar

```js
function handler() {
  console.log("click");
}
btn.addEventListener("click", handler);
// ...
btn.removeEventListener("click", handler);
```

---

### Ejercicio 3 â€” Evitar variables globales

âŒ Mal

```js
contador = 0;
```

âœ… Bien

```js
let contador = 0;
```

---

### Ejercicio 4 â€” Referencias grandes

```js
let buffer = new Array(1000000).fill(0);
// ...
buffer = null; // liberar memoria
```

---

### Ejercicio 5 â€” Detectar problema real

```js
function fuga() {
  let data = [];
  return () => data.push(Date.now());
}
const f = fuga();
// cada llamada aumenta memoria
```

---

## ğŸš€ Retos

1. Crea una funciÃ³n que registre eventos, pero asegÃºrate de limpiarlos tras usarlos.
2. Haz un temporizador "seguro" que pueda iniciarse y detenerse sin filtrar memoria.
3. Simula un leak y encuentra cÃ³mo corregirlo usando herramientas de "Performance" del navegador.