AquÃ­ tienes **4.3 â€“ Usando finally** para completar el mÃ³dulo de manejo de excepciones.

---

# 4.3 Usando finally

## ðŸ”§ Â¿QuÃ© es finally?

`finally` es una parte opcional del bloque `try/catch` que **siempre se ejecuta**, haya error o no.
Sirve para **liberar recursos**, **cerrar conexiones**, **limpiar estados** o **mostrar mensajes finales**.

Estructura:

```js
try {
  // CÃ³digo que puede fallar
} catch (error) {
  // CÃ³digo cuando ocurre error
} finally {
  // Siempre se ejecuta, pase lo que pase
}
```

---

## âœ… Ejemplo bÃ¡sico

```js
try {
  console.log("Intentando ejecutar cÃ³digo...");
  throw new Error("FallÃ³ algo");
} catch (error) {
  console.log("Capturado:", error.message);
} finally {
  console.log("Esto siempre se ejecuta");
}
```

Salida:

```
Intentando ejecutar cÃ³digo...
Capturado: FallÃ³ algo
Esto siempre se ejecuta
```

---

## ðŸ’¡ Caso de uso: limpiar recursos

```js
function procesarArchivo() {
  console.log("Abriendo archivo...");
  try {
    throw new Error("No se pudo leer el archivo");
  } catch (error) {
    console.log("Error:", error.message);
  } finally {
    console.log("Cerrando archivo...");
  }
}

procesarArchivo();
```

---

## ðŸ§¼ Buen hÃ¡bito: limpiar conexiones o estados

```js
let conectado = false;

try {
  conectado = true; // simular conexiÃ³n
  console.log("Conectado a la base de datos");
  throw new Error("Oops");
} catch {
  console.log("Ha ocurrido un error");
} finally {
  conectado = false; // desconexiÃ³n asegurada
  console.log("ConexiÃ³n cerrada:", conectado);
}
```

---

# ðŸ›  Laboratorio

## ðŸŽ¯ Objetivos

* Entender cuÃ¡ndo usar finally
* Evitar fugas de estado o recursos
* Garantizar limpieza siempre

---

### Ejercicio 1 â€” finally bÃ¡sico

Completa este cÃ³digo para que siempre muestre "Proceso terminado", ocurra o no error.

```js
try {
  console.log("Ejecutando operaciÃ³n...");
} catch {
  console.log("Hubo un fallo");
} finally {
  console.log("Proceso terminado");
}
```

---

### Ejercicio 2 â€” Simular limpieza

```js
let cargado = false;

try {
  cargado = true;
  console.log("Recurso cargado");
  throw new Error("Simulando error");
} catch (e) {
  console.log("Error:", e.message);
} finally {
  cargado = false;
  console.log("Recurso liberado:", cargado);
}
```

---

### Ejercicio 3 â€” DivisiÃ³n segura

Modifica la funciÃ³n para que SIEMPRE muestre un mensaje final:

```js
function dividir(a, b) {
  try {
    if (b === 0) throw new Error("No se puede dividir por cero");
    console.log(a / b);
  } catch (error) {
    console.log("Error:", error.message);
  } finally {
    console.log("Fin de la operaciÃ³n");
  }
}

dividir(10, 2);  // Fin de la operaciÃ³n
dividir(5, 0);   // Fin de la operaciÃ³n
```

---

### Ejercicio 4 â€” Registro de acciones

Haz que siempre se registre la operaciÃ³n aunque falle.

```js
function procesar(numero) {
  try {
    if (typeof numero !== "number") throw new TypeError("Debe ser nÃºmero");
    console.log("Procesado:", numero * 2);
  } catch (e) {
    console.log("Error:", e.message);
  } finally {
    console.log("Log: operaciÃ³n con valor =", numero);
  }
}
```

---

## ðŸš€ Retos

1. Crea una funciÃ³n `abrirSesion(usuario)` que siempre cierre la sesiÃ³n en finally, aunque falle.
2. Simula abrir un archivo, leerlo y cerrarlo en finally.
3. Implementa un contador de errores que SIEMPRE aumente si hubo excepciÃ³n.

---

Â¿Continuamos con **5.1 Oyentes de eventos**? ðŸ”¥
